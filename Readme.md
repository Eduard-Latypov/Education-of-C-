# Мое обучение языку программирования С#

Я начал обучаться данному языку с первой лекции по С# на платформе GeekBrains
то есть 27.11.2022 года! До этого моменты я никогда не сталкивался и не изучал этот язык!
Посмотрим какие будут успехи спустя определенное время!

## Мои успехи в изучении языка в виде списков:

---

1.  Написал программу Hello world!
2.  Написал программу считывающую числа в виде строки с консоли, переводит эти данные в числовой тип данных и производит некие опреции над этими числами
3.  Написал класс и объект внутри которых можно писать программу
4.  Если указать тип переменной, то после уже этот тип поменять нельзы, но можно переназначить значение этой переменной.
5.  Ветвление в С#
6.  Инкремент и декремент, постфиксный и префиксный
7.  Логические операторы && и || то есть and и or.
8.  Создал калькулятор с применением функций switch, case, default.
9.  Добавил цикл while в калькулятор, дабы он мог работать до тех пор, пока пользователь не прекратит его работу.
10. Изучил цикл **do while**, интересная конечно у него работа в отличие от того же самого **while**. Цикл **do while** отличается от классического **while** тем, что **while** сначало проверяет условие, и если условие истинно, то уже после выполняет действие, а **do while** сначало выполняет действие а после уже проверяет условие, даже если условие ложно, то **do while** в любом случае успеет выполнить хоть одно действие!
11. Оказывается существует лайфхак: если набрать "cw" и нажать tab, то автоматически напечатается System.Console.WriteLine что очень сильно упрощает работу с выводом чего-либо на консоль!))
12. Изучил цикл **for**, интересная конечно у него конструкция где в скобках прописывается сразу и старт и конец и шаг, хотя может так и должно быть, я то сравниваю синтаксис с Python.
13. Изучил вариации выполнения цикла **for**, оказывается если убрать все параметры в скобках **for** и оставить только 2 пары точки с запятой, то получится бесконечный цикл. Есть возможность в параметрах указывать не только одну переменную а бесконечное число (правда читаемость такого кода будет никудышней, но это другой вопрос), можно в параметрах также указывать несколько условий остановки цикла используя логические операторы && или ||. Также, если в третьем параметре указать декрмент а не инкремент, то цикл будет выполняться в обратном порядке, правда для этого нужно чтобы переменная была больше нуля (если мы собираемся идти от числа к нулю), и условие пока переменная будет >= нулю.
14. Изучил операторы прерывания и продолжения break и continue. Они используются в циклах (while, do-while, for). Пишится циклы и условие для цикла, если мы не знаем какое количество итераций должен выполнить цикл, то в таком случае удобно использовать оператор break, в связке с каким либо условием, то есть в теле цикла прописывается условие при выполнении которого цикл останавливается! Логика выполнения оператора Continue такая же, как в принципе и в питоне, то есть в теле цикла прописыается условие, при выполнении, которого цикл "перепрыгивает" это (значение, условие) и продолжает дальше свою работу!
15. Вложенные циклы. В принципе ничего сложного, все то же самое, что и в питоне разница только в синтаксисе!
16. Тернарный оператор. Интереснейшая конечно конструкция, в то же время не совсем понятная. Если есть if else, то зачем нужен тернарный оператор? Не понятно! Но тем не менее может в какой-то степени (условно) облегчить написание некоторого скрипта. Конструкция **[тип переменная = условие ? значение : значение_2]** в переменную присваивается значение или значение\*2 в зависимости от условий выполнения условия. Например: **[string word = num % 2 == 0 ? True : False]** - в переменной **word** с типом **string** будет записано **True** если условие **num % 2 == 0** верно или **False** если условие **num % 2 == 0** неверно!
17. Массивы. Небольшое отличие от питона, то есть сначало объявляется массив **int[] myArray;** а после в оперативной памяти, в управляемой куче выделяется память для элементов массива, то на следующей строчке кода указываем сколько элементов будет в массиве **myArray = new int[10]**. Таким образом мы имеем массив с 10 целыми числами то есть нулями по умолчанию. В отличие от динамически типизированных языков коим является Питон, С# строгой типизации, а соответственно массивы содержат исключительно однотипные элементы, то есть если мы объявили массив и указали. что в нем будут только целочисленные элементы, соответственно элементами данного массива будут только целые числа.
18. Взаимодейсвтие с массивами путем применения цикла **for**, заполнение массива, вывод массива поэлементно, взаимодействие с элементами массива (нахождение минимального элемента, сумма четных элементов, вывод массива на печать в обратном порядке)!
19. Списочные методы. Их, как оказалось довольно много! (Find, Sort, Reverse, FirstOrDefault, Append и т.д.)
20. Cрезы списков. В принципе то же самое, что и в питоне, единственное отличие в питоне срез обозначается двоеточием (:), а в С# срез обозначается двумя точками (..). И последний элемент в списке в C# это (^1), то есть не (-1) как в питоне, а (^1).
21. Двумерные массивы. Инициализация двумерного массива идентична инициализации одномерного массива, за исключение, что в в квадратных скобках нужно указывать запятую то есть **int[] myArray = new int[5];** одномерный массив, а **int[,] myArray = new int[3, 5];** двумерный массив, который имеет 3 строки и 5 колонн.
22. Списочный метод **myArray.Rank;** показывает скольки уровневый массив, циклом **foreach (var item in collection)** можно перебрать все элементы массива вне зависимости от уровня вложенности (печатает все элементы либо одним столбиком, либо в одну строку(невозможо вывести таблицей)), метод
    **myArray.GetLength(0)** возвращает количество элементов первого уровня массива, **myArray.GetLength(1)** возвращает количество элементов второго уровня массива и т.д.
23. Зубчатые массивы. По сути это двумерный не прямоугольный и не квадратный массив, но C# считает это одномерным массивом элементами, которого являются другие массивы :D. Ну ок, одномерный так одномерный. Синтаксис объявления такого массива отличается от синтаксиса двумерного массива то есть ты сначала объявляешь массив **int[][] myArray = new int[5][];**, который показывает что ты хочешь создать НЕодномерный массив, вложенные массивы которого могут иметь разные длины, а потом с новой строки указываешь длину каждого ~~вложенного~~ массива то есть:
    **myArray[0] = new int[4];**
    **myArray[0] = new int[5];**
    **myArray[0] = new int[6];**
    **myArray[0] = new int[7];**
    **myArray[0] = new int[8];**

Это показывает длину каждого ~~вложенного~~ массива. После можно уже заполнять массив данными. Кстати для перебора всех элементов такого зубчатого массива можно воспользоваться циклом **for**, но в качестве аргументы во вложенном цикле, показывающая длину массива, нужно передавать НЕ **myArray.GetLength(0)**, а **myArray[i].Length**, где **i** переменная из внешнего цикла! И вывод элементов такого массива будет иметь синтаксис **myArray[i][j]** А НЕ **myArray[i, j]**.

24. Трехмерные массивы. **int[,,] myArray = new int[4, 3, 5]** создает трехмерный массив. 4-это глубина вложенности, 3-строка, 5-столбец!

25. Трехмерные зубчатые массивы. **int[][][] myArray = new int[][][];** все то же самое, что и с обычным зубчатым массивом, но квдратных скобок больше.

26. Функции. В принципе все, то же самое, что и в питоне, единственное отличие это то, что функция в С# в отличие от питона может вызываться до ее определения! И еще, перед названием функции цказывается тип, который будет возвращаться, а если функци ничего не возвращает, то перед названием функции пишется слово **void**.
27. Стек и управляемая куча(Heap). Стек - это небольшая область в оперативной памяти, дефолтный объем которой равен 1 мб и она работает очень быстро, управляемая куча - это так же область в оперативной памяти, которая работает чуть медленнее чем стек, но ее объем в зависимости от разряда вашей операционной системы может быть огромной (например в 64 разрядной системе объем кучи может доходить до 8тб). Все объекты, которые относятся к **struct(структура)** или **enum** будут храниться в стеке, а объекты **reference(ссылочные)**, хранятся в управляемой куче, в стеке лишь хранятся переменные, которые содержат ссылки на объекты в управляемой куче Например: массив **int[] myArray = new int[10]** в этом случае в стеке хранится переменная по имени **myArray** а в управляемой куче хранится сам массив из 10 нулей. Стек работает по принципу **last in - first out (последний вошел - первый вышел)**, то есть чтобы добраться до объекта, который был добавлен в стек первым, нужно перебрать все объекты, которые были добавлены в стек после него, и время жизни объектов в стеке зависит от контекста (тела) программы, которая использует эту переменную то есть если мы объявили функцию и в теле этой функции используем какую - либо переменную, то время жизни этой переменной в стеке длится до тех пор, пока работает эта функция, то есть как только функция отработала, то переменная стирается из стека. В случае с управляемой кучей все немного сложнее, память в ней освобождается Garbage collector (сборщиком мусора), у которого свои алгоритмы работы!
28. Null-объединение - это по сути синтаксический сахар, который позволяет указывать (подставлять) дефолтное значение для ссылочных типов данных. Дефолтное значение, которое вы указываете должно быть такого же типа данных, что и сама переменная куда это значение подставляется! Синтаксис
    **переменная ?? дефолтное значение**. Если же после **??** поставить равно, то есть **??=**, то этой переменной ПРИСВОИТСЯ значение, которое мы указали после знака (=), то есть в первом случае мы подставляем значение а во втором мы присваиваем это значение переменной.
29. Область видимости переменной или контекст. К переменной объявленной в основной программе может иметь доступ любая функция, а к перменной объявленной в функции можно получить доступ только непосредственно из самой функции.
30. Ref и Out. Это модификаторы функций. То есть, если мы передаем в функцию какую-либо переменную, то все телодвижения, которые мы совершаем с этой переменной в функциии остаются в функции и не выходят за пределы ее(функции), то если же мы при объявление функции указываем в скобках параметр с модификатором ref и во время вызова этой функции мы передадм аргумент с модификатором ref, то все наши действия внутри функции с этой переменной будут действовать и за пределами этой функции, другими словами это, то же самое, что и global в питоне. Также, допустим мы можем передать в функцию массив и поменять ее какой-то элемент, это повлечет и изменение этого элемента и за пределами функции, но мы не можем менять размер массива или же прописывать в переменную содержащую массив **null**, с модификатором ref это возможно. Что касается out, то это идентичный ref модификатор за исключением того, что ref нас не обязывает как-либо изменять переменную или массив, то есть как приняли так и можем вернуть, а вот out обязывает это делать, программа даже не скомпилируется, если не внести изменения в ту переменную, еоторую мы передавали в функцию с модификатором out.
31. Модификатор **in**, по сути такой же как и модификаторы **ref или out**, но он не позволяет вносить какие-либо изменения в переменную, которая передается в функцию с параметром **in** то есть мы можем просматривать значения этой переменной, использовать в каких-то вычислениях, но не можем вносить изменения. Отличие же модификатора **in** от того, что если бы мы передавали без него в том, что когда мы передаем аргумент в параметр без модификатора **in**, то данные переменной копируются, что снижает эффективность выполнения вашей программы, если переменная тяжелая. В случае же если мы передадим переменную в качестве аргументы в параметр с модификатором **in**, то копируется лишь ссылка на эту переменную и плюс мы имеем гаррантию того, что внутри функции эта переменная никоим образом не изменится. Кстати говоря о преимуществах ссылки вместо копирования, то это ЗНАЧИТЕЛЬНО ускоряет время выполнения вашей программы!!!
32. Модификатор **params** это то же самое, что и **(**kwargs)** в питоне, то есть он принимает в себя неограниченное количество параметров и возвращет спикок то есть массив этих значений.
    Синтаксис **int Foo(params int[] parameters)\*\* позволяет при вызове функции передавать в аргументах любое количество целых чисел и функция вернет массив с именем parameters, который содержит все эти целые числа.
33. Рекурсия. Рекурсия - это вызов функции внутри функции, то есть, если функция (метод) внутри себя вызвает саму себя то это и есть реурсия. При написании или создании рекурсии нужно обязательно указать условие для выхода из рекурсии. В противном случае мы рискуем получить **StackOverFlow**, то есть переполнение стека. Дело в том, что при вызове функции она появляется в стеке и хранится там до тех пор, пока не будет выход из функции, соответственно, если мы в теле функции вызываем опять функцию то и эта функция появится в стеке и т.д., а учитывая, что стек не резиновый, то не далек момент, когда он переполнится и мы получим ошибку **StackOverFlowException**!
34.
